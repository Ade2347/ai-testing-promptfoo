import { z } from 'zod';
import { type FetchWithCacheResult } from '../cache';
import type { ApiProvider, CallApiContextParams, ProviderOptions, ProviderResponse } from '../types';
export declare function urlEncodeRawRequestPath(rawRequest: string): string;
/**
 * Generate signature using different certificate types
 */
export declare function generateSignature(signatureAuth: any, signatureTimestamp: number): Promise<string>;
export declare const HttpProviderConfigSchema: z.ZodObject<{
    body: z.ZodOptional<z.ZodUnion<[z.ZodRecord<z.ZodString, z.ZodAny>, z.ZodString, z.ZodArray<z.ZodAny, "many">]>>;
    headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    maxRetries: z.ZodOptional<z.ZodNumber>;
    method: z.ZodOptional<z.ZodString>;
    queryParams: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    request: z.ZodOptional<z.ZodString>;
    useHttps: z.ZodOptional<z.ZodBoolean>;
    sessionParser: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[], z.ZodUnknown>, z.ZodUnknown>]>>;
    transformRequest: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[], z.ZodUnknown>, z.ZodUnknown>]>>;
    transformResponse: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[], z.ZodUnknown>, z.ZodUnknown>]>>;
    url: z.ZodOptional<z.ZodString>;
    validateStatus: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodNumber], z.ZodUnknown>, z.ZodBoolean>]>>;
    /**
     * @deprecated use transformResponse instead
     */
    responseParser: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[], z.ZodUnknown>, z.ZodUnknown>]>>;
    tokenEstimation: z.ZodOptional<z.ZodObject<{
        enabled: z.ZodDefault<z.ZodBoolean>;
        multiplier: z.ZodDefault<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        enabled: boolean;
        multiplier: number;
    }, {
        enabled?: boolean | undefined;
        multiplier?: number | undefined;
    }>>;
    signatureAuth: z.ZodOptional<z.ZodUnion<[z.ZodEffects<z.ZodObject<{
        signatureValidityMs: z.ZodDefault<z.ZodNumber>;
        signatureDataTemplate: z.ZodDefault<z.ZodString>;
        signatureAlgorithm: z.ZodDefault<z.ZodString>;
        signatureRefreshBufferMs: z.ZodOptional<z.ZodNumber>;
    } & {
        type: z.ZodLiteral<"pem">;
        privateKeyPath: z.ZodOptional<z.ZodString>;
        privateKey: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "pem";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
    }, {
        type: "pem";
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
    }>, {
        type: "pem";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
    }, {
        type: "pem";
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
    }>, z.ZodObject<{
        signatureValidityMs: z.ZodDefault<z.ZodNumber>;
        signatureDataTemplate: z.ZodDefault<z.ZodString>;
        signatureAlgorithm: z.ZodDefault<z.ZodString>;
        signatureRefreshBufferMs: z.ZodOptional<z.ZodNumber>;
    } & {
        type: z.ZodLiteral<"jks">;
        keystorePath: z.ZodString;
        keystorePassword: z.ZodOptional<z.ZodString>;
        keyAlias: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "jks";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        keystorePath: string;
        signatureRefreshBufferMs?: number | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
    }, {
        type: "jks";
        keystorePath: string;
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
    }>, z.ZodEffects<z.ZodObject<{
        signatureValidityMs: z.ZodDefault<z.ZodNumber>;
        signatureDataTemplate: z.ZodDefault<z.ZodString>;
        signatureAlgorithm: z.ZodDefault<z.ZodString>;
        signatureRefreshBufferMs: z.ZodOptional<z.ZodNumber>;
    } & {
        type: z.ZodLiteral<"pfx">;
        pfxPath: z.ZodOptional<z.ZodString>;
        pfxPassword: z.ZodOptional<z.ZodString>;
        certPath: z.ZodOptional<z.ZodString>;
        keyPath: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "pfx";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
    }, {
        type: "pfx";
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
    }>, {
        type: "pfx";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
    }, {
        type: "pfx";
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
    }>, z.ZodObject<{
        signatureValidityMs: z.ZodDefault<z.ZodNumber>;
        signatureDataTemplate: z.ZodDefault<z.ZodString>;
        signatureAlgorithm: z.ZodDefault<z.ZodString>;
        signatureRefreshBufferMs: z.ZodOptional<z.ZodNumber>;
    } & {
        privateKeyPath: z.ZodOptional<z.ZodString>;
        privateKey: z.ZodOptional<z.ZodString>;
        keystorePath: z.ZodOptional<z.ZodString>;
        keystorePassword: z.ZodOptional<z.ZodString>;
        keyAlias: z.ZodOptional<z.ZodString>;
        keyPassword: z.ZodOptional<z.ZodString>;
        pfxPath: z.ZodOptional<z.ZodString>;
        pfxPassword: z.ZodOptional<z.ZodString>;
        certPath: z.ZodOptional<z.ZodString>;
        keyPath: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
        keystorePath?: string | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
        keyPassword?: string | undefined;
    }, {
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
        keystorePath?: string | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
        keyPassword?: string | undefined;
    }>]>>;
}, "strip", z.ZodTypeAny, {
    url?: string | undefined;
    headers?: Record<string, string> | undefined;
    method?: string | undefined;
    body?: string | any[] | Record<string, any> | undefined;
    queryParams?: Record<string, string> | undefined;
    maxRetries?: number | undefined;
    request?: string | undefined;
    useHttps?: boolean | undefined;
    sessionParser?: string | ((...args: unknown[]) => unknown) | undefined;
    transformRequest?: string | ((...args: unknown[]) => unknown) | undefined;
    transformResponse?: string | ((...args: unknown[]) => unknown) | undefined;
    validateStatus?: string | ((args_0: number, ...args: unknown[]) => boolean) | undefined;
    responseParser?: string | ((...args: unknown[]) => unknown) | undefined;
    tokenEstimation?: {
        enabled: boolean;
        multiplier: number;
    } | undefined;
    signatureAuth?: {
        type: "pem";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
    } | {
        type: "jks";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        keystorePath: string;
        signatureRefreshBufferMs?: number | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
    } | {
        type: "pfx";
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
    } | {
        signatureValidityMs: number;
        signatureDataTemplate: string;
        signatureAlgorithm: string;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
        keystorePath?: string | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
        keyPassword?: string | undefined;
    } | undefined;
}, {
    url?: string | undefined;
    headers?: Record<string, string> | undefined;
    method?: string | undefined;
    body?: string | any[] | Record<string, any> | undefined;
    queryParams?: Record<string, string> | undefined;
    maxRetries?: number | undefined;
    request?: string | undefined;
    useHttps?: boolean | undefined;
    sessionParser?: string | ((...args: unknown[]) => unknown) | undefined;
    transformRequest?: string | ((...args: unknown[]) => unknown) | undefined;
    transformResponse?: string | ((...args: unknown[]) => unknown) | undefined;
    validateStatus?: string | ((args_0: number, ...args: unknown[]) => boolean) | undefined;
    responseParser?: string | ((...args: unknown[]) => unknown) | undefined;
    tokenEstimation?: {
        enabled?: boolean | undefined;
        multiplier?: number | undefined;
    } | undefined;
    signatureAuth?: {
        type: "pem";
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
    } | {
        type: "jks";
        keystorePath: string;
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
    } | {
        type: "pfx";
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
    } | {
        signatureValidityMs?: number | undefined;
        signatureDataTemplate?: string | undefined;
        signatureAlgorithm?: string | undefined;
        signatureRefreshBufferMs?: number | undefined;
        privateKeyPath?: string | undefined;
        privateKey?: string | undefined;
        keystorePath?: string | undefined;
        keystorePassword?: string | undefined;
        keyAlias?: string | undefined;
        pfxPath?: string | undefined;
        pfxPassword?: string | undefined;
        certPath?: string | undefined;
        keyPath?: string | undefined;
        keyPassword?: string | undefined;
    } | undefined;
}>;
type HttpProviderConfig = z.infer<typeof HttpProviderConfigSchema>;
interface SessionParserData {
    headers?: Record<string, string> | null;
    body?: Record<string, any> | string | null;
}
export declare function createSessionParser(parser: string | Function | undefined): Promise<(data: SessionParserData) => string>;
interface TransformResponseContext {
    response: FetchWithCacheResult<any>;
}
export declare function createTransformResponse(parser: string | Function | undefined): Promise<(data: any, text: string, context?: TransformResponseContext) => ProviderResponse>;
/**
 * Substitutes template variables in a JSON object or array.
 *
 * This function walks through all properties of the provided JSON structure
 * and replaces template expressions (like {{varName}}) with their actual values.
 * If a substituted string is valid JSON, it will be parsed into an object or array.
 *
 * Example:
 * Input: {"greeting": "Hello {{name}}!", "data": {"id": "{{userId}}"}}
 * Vars: {name: "World", userId: 123}
 * Output: {"greeting": "Hello World!", "data": {"id": 123}}
 *
 * @param body The JSON object or array containing template expressions
 * @param vars Dictionary of variable names and their values for substitution
 * @returns A new object or array with all template expressions replaced
 */
export declare function processJsonBody(body: Record<string, any> | any[] | string, vars: Record<string, any>): Record<string, any> | any[] | string;
/**
 * Substitutes template variables in a text string.
 *
 * Replaces template expressions (like {{varName}}) in the string with their
 * actual values from the provided variables dictionary.
 *
 * Example:
 * Input: "Hello {{name}}! Your user ID is {{userId}}."
 * Vars: {name: "World", userId: 123}
 * Output: "Hello World! Your user ID is 123."
 *
 * @param body The string containing template expressions to substitute
 * @param vars Dictionary of variable names and their values for substitution
 * @returns A new string with all template expressions replaced
 * @throws Error if body is an object instead of a string
 */
export declare function processTextBody(body: string, vars: Record<string, any>): string;
export declare function createTransformRequest(transform: string | Function | undefined): Promise<(prompt: string) => any>;
export declare function determineRequestBody(contentType: boolean, parsedPrompt: any, configBody: Record<string, any> | any[] | string | undefined, vars: Record<string, any>): Record<string, any> | any[] | string;
export declare function createValidateStatus(validator: string | ((status: number) => boolean) | undefined): Promise<(status: number) => boolean>;
/**
 * Estimates token count for a given text using word-based counting
 */
export declare function estimateTokenCount(text: string, multiplier?: number): number;
export declare class HttpProvider implements ApiProvider {
    url: string;
    config: HttpProviderConfig;
    private transformResponse;
    private sessionParser;
    private transformRequest;
    private validateStatus;
    private lastSignatureTimestamp?;
    private lastSignature?;
    constructor(url: string, options: ProviderOptions);
    id(): string;
    toString(): string;
    /**
     * Estimates token usage for prompt and completion text
     */
    private estimateTokenUsage;
    private refreshSignatureIfNeeded;
    private getDefaultHeaders;
    private validateContentTypeAndBody;
    getHeaders(defaultHeaders: Record<string, string>, vars: Record<string, any>): Promise<Record<string, string>>;
    callApi(prompt: string, context?: CallApiContextParams): Promise<ProviderResponse>;
    private callApiWithRawRequest;
    /**
     * Extracts completion text from parsed output with fallback to raw text
     */
    private getCompletionText;
    /**
     * Processes response and adds token estimation if enabled
     */
    private processResponseWithTokenEstimation;
}
export {};
//# sourceMappingURL=http.d.ts.map